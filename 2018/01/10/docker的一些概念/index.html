<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Zhangguanzhang">
  <!-- Open Graph Data -->
  <meta property="og:title" content="docker的一些概念"/>
  <meta property="og:description" content="记录生活点滴" />
  <meta property="og:site_name" content="Zhangguanzhang"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://zhangguanzhang.github.ioundefined"/>
  <meta name="baidu-site-verification" content="RqbanSZBE3" />
  
    <link rel="alternate" href="/atom.xml" title="Zhangguanzhang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Zhangguanzhang</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">docker的一些概念</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/zhangguanzhang">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:zhangguanzhang@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Zhangguanzhang</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-01-10</span>
            <span class="time">00:46:24</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/日志/">日志</a> / <a href="/categories/日志/容器/">容器</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/docker/">#docker</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>总结下容器的一些概念和虚拟机的区别以及CMD和entrypoint<br><a id="more"></a><br>先直接切入主题，容器好处和虚拟机的一些差异可以看下面的博客<br><a href="http://www.cnblogs.com/linuxops/p/6781047.html" target="_blank" rel="external">http://www.cnblogs.com/linuxops/p/6781047.html</a></p>
<p>容器是利用linux的cgroup和namespace隔离的，在宿主机上本质是个隔离的进程。因为是进程，一个容器(进程)要一直运行，那容器里得有个主进程一直运行。<br>容器很多东西(命令，文件啥的)和虚拟机有点类似，但是你不能把它当虚拟机用，因为容器本质是解耦的，一个容器一个业务<br>可以这样假想下，拿nginx这个来举例子，nginx其实就是个进程和配置文件还有静态网页啥的+一台服务器(环境)，服务器上有其他不需要的东西，容器就是个最小系统，然后安装了nginx</p>
<p>安装了docker后(建议别虚拟机)，一般教程是举例<br>第一个容器命令是<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span><span class="bash"> -ti centos /bin/bash</span></div></pre></td></tr></table></figure></p>
<p>也可能是<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span><span class="bash"> <span class="_">-d</span> -p 80:80 nginx</span></div></pre></td></tr></table></figure></p>
<p>一般来讲入门最先接触的就是docker run这个命令,这个命令可以理解为先查找本地有没有镜像<br>没有就从dockerhub拉取，然后镜像运行后就叫做容器<br>看下命令说明<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker run --help</span></div><div class="line"></div><div class="line">Usage:	docker <span class="keyword">run</span><span class="bash"> [OPTIONS] IMAGE [COMMAND] [ARG...]</span></div><div class="line"></div><div class="line"><span class="keyword">Run</span><span class="bash"> a <span class="built_in">command</span> <span class="keyword">in</span> a new container</span></div></pre></td></tr></table></figure></p>
<p>先看命令帮助的一部分，<br>命令格式是docker run [选项] 镜像名 [命令] [参数]<br>是说在一个新容器里运行一个命令，但是用法部分显示command和command的arg部分是可选的，选项也是可选的<br>从上面两个常见的命令看看一个有command，一个没有，选项部分在剩下的docker run –help里<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">i, --interactive                    Keep STDIN open even <span class="keyword">if</span> <span class="keyword">not</span> attached</span></div><div class="line">-<span class="ruby">p, --publish list                   Publish a container<span class="string">'s port(s) to the host</span></span></div><div class="line">-<span class="ruby"><span class="string">t, --tty                            Allocate a pseudo-TTY</span></span></div></pre></td></tr></table></figure></p>
<p>-i是交互选项,-t是tty终端，-p是把容器的端口映射到宿主机的端口(可以多个-p选项)</p>
<p>前面说了，容器实质是个宿主机上的一个进程，一个进程一直运行容器就必须有主进程<br>上面两个命令的command部分其实就是所谓的主进程<br>至于nginx的为啥没有这就从构建镜像来讲<br>前面说了可以假想下容器是个最小系统安装了你要跑的业务进程<br>那如何构建自己的镜像呢，就是Dockerfile<br>有FROM命令，选取一个基础镜像构建,具体的dockerfile一些常用的可以去上面那个博客去看下，功能不会造成歧义，挺好记住的<br>就是个CMD和entrypoint很多人搞不清楚<br>拿nginx的官方的dockerfile来举例简化成下面的大概样子<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> xxx:xxx</div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install nginx</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"nginx"</span>,<span class="string">"-g"</span>,<span class="string">"deamon off"</span>]</span></div></pre></td></tr></table></figure></p>
<p>nginx镜像的主进程就是这个nginx -g deamon off的nginx前台命令作为默认的CMD<br>这就是为啥run nginx容器的时候不需要，因为run的时候结尾的command为空默认使用构建镜像写的CMD<br>默认的command可以通过docker inspect 镜像名 输出的一堆json找Cmd部分查看<br>然后结尾有cmd的话会覆盖掉默认的CMD<br>然后为啥那个-ti centos /bin/bash这么常见，很多人因为不懂在它的执行结果上把容器当作虚拟机了<br>先讲下非/bin/bash的cmd是啥效果<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@guan ~]# docker run -d centos ls</div><div class="line"><span class="number">24</span>b2195731fef5b3e52898bcb7e2c6cebdb9afb8cfc929c1e69ed7126e967699</div><div class="line">[root@guan ~]# docker run -d centos sleep <span class="number">10</span></div><div class="line"><span class="number">8</span>c0a7cba4af9a847e0092e1855426149cf093ef90fd4b91b1cbf452001176a38</div><div class="line">[root@guan ~]# docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS                                      NAMES</div><div class="line"><span class="number">8</span>c0a7cba4af9        centos              <span class="string">"sleep 10"</span>               <span class="number">4</span> seconds ago       Up <span class="number">3</span> seconds                                                     cocky_visvesvaraya</div><div class="line"><span class="number">24</span>b2195731fe        centos              <span class="string">"ls"</span>                     <span class="number">10</span> seconds ago      Exited (<span class="number">0</span>) <span class="number">9</span> seconds ago                                         friendly_mirzakhani</div><div class="line">[root@guan ~]# docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                          PORTS                                      NAMES</div><div class="line"><span class="number">8</span>c0a7cba4af9        centos              <span class="string">"sleep 10"</span>               About a minute ago   Exited (<span class="number">0</span>) <span class="number">15</span> seconds ago                                       cocky_visvesvaraya</div><div class="line"><span class="number">24</span>b2195731fe        centos              <span class="string">"ls"</span>                     About a minute ago   Exited (<span class="number">0</span>) <span class="number">29</span> seconds ago                                       friendly_mirzakhani</div></pre></td></tr></table></figure></p>
<p>上面用centos镜像(-d选项是把容器后台运行，毕竟容器执行命令，你不后台你就要灯带容器执行完命令)来执行了两个命令<br>一个cmd是ls，一个是sleep 10<br>然后全部后台后用docker ps -a查看所有容器状态信息可以看到ls那个容器已经退出，sleep 10这个没退出,但是10秒过后这个容器也退出了<br>形象的说明了容器是需要主进程一直执行的<br>现在说下docker run -ti centos /bin/bash，很多命令需要交互终端来交互最常见的bash，所以一般-ti是成对出现的<br>你运行了docker run -ti centos /bin/bash后会进入一个生成的新容器里的交互式bash终端，这个时候很多初学者看到这个现象误以为容器是虚拟机<br>其实这样这个bash充当了主进程的身份而已，你可以ctrl+c退出这个交互式bash容器就退出了<br>可能有些人就挑出来说-d不是后台吗，我-tid就可以一直不退出了，或者说我容器先跑个业务进程，然后cmd部分是个死循环命令，不也可以吗<br>这样可以是可以的，但是违背了容器的设计理念，但是容器的设计理念，还有方便收集日志以及解耦性，最后一个容器跑一个业务，且这个业务是主进程<br>然后说下docker exec，看看docker exec –help输出<br>格式和docker run差不多<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker exec --help</span></div><div class="line"></div><div class="line">Usage:	docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</div><div class="line"></div><div class="line"><span class="keyword">Run</span><span class="bash"> a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span></div></pre></td></tr></table></figure></p>
<p>使用容器运行一个命令，但是可以说八成以上的用的都是<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -ti 容器<span class="built_in">id</span>  /bin/bash</div></pre></td></tr></table></figure></p>
<p>这样是进入了容器内部了,很多非运维的人不看命令帮助，又经常看到别人这么用误以为是exec是进入容器内部<br>其实是仅仅执行一个命令而已，看下实际出真知<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root<span class="symbol">@guan</span> ~]<span class="meta"># docker run -d nginx</span></div><div class="line"><span class="number">8</span>c85f22f644cab32ef3dd4637e88ce799023a70f93656db0c20c8b1b70ee69d2</div><div class="line">[root<span class="symbol">@guan</span> uwsgi-django]<span class="meta"># docker exec 8c8 ls</span></div><div class="line">bin</div><div class="line">boot</div><div class="line">dev</div><div class="line">etc</div><div class="line">home</div><div class="line">....输出省略</div><div class="line">[root<span class="symbol">@guan</span> ~]<span class="meta">#</span></div></pre></td></tr></table></figure></p>
<p>上面运行了一个nginx容器(然后输出信息是容器的id，使用容器id的地方不需要写全，开头几位以后能表示唯一的就行了)然后用它执行了一个ls命令<br>不能因为exec多用于进入容器内部的bash而认为exec是进入容器的命令(我刚开始也这么认为，甚至网上很多人博客也这么说)</p>
<p>现在说下CMD和entrypoint的关系<br>两者都存在情况下，CMD是传递给entrypoint当作参数的<br>比如你某个主进程的某些参数需要固定，可以把那些部分写在entrypoint那<br>但是实际应用场景里，entrypoint大多都是shell脚本<br>因为shell脚本可以接受参数来逻辑代码(虽然其他也可以,但是shell自带的)<br>为啥实际场景里应用得多，是因为到现在dockerfile都是固定的，或者说某些步骤像在容器启动后主进程启动前执行<br>一个dockerfile只能有一个CMD和entrypoint，所以entrypoint使用shell脚本就能解决这个需求<br>我用python来举例子<br>一个标准的python项目目录里一个有个requirements.txt写有了所有的依赖扩展,虽然你可以在写dockerfile的时候COPY进去然后RUN pip install -r requirements.txt安装随后启动<br>如果这样的情况多了起来你肯定想寻求一个自动执行的方法<br>先看看redis官方的做法,他们是一个shell脚本作为entrypoint的命令，脚本内容如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment">#allow the container to be started with `--user`</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> <span class="_">-a</span> <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></div><div class="line">    chown -R redis .</div><div class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></div></pre></td></tr></table></figure></p>
<p>$1就是接收到的第一部分参数，也就是cmd里第一部分，如果run的cmd是sleep 10，那么第一个参数就是sleep了<br>脚本逻辑是如果第一部分参数是redis-server(也就是docker run …. redis redis-server)并且脚本执行的用户是root，配置权限后exec前台执行redis服务,然后不是的画就是最后<br>一行的那个exec “$@”了，$@在shell里表示收到的所有参数，也就是exec前台执行用户run 镜像名的最后的所有cmd部分<br>那现在写一个通用的容器的话,先了解几点,dockerfile的WORKDIR后面目录是在镜像里创建的，没有就创建并且进入到这个目录<br>所以所有的cmd都是在WORKDIR里执行的，如果你把文件挂载到了这个目录(官方也建议挂载到这个目录)可以不用写绝对路径<br>写通用型entrypoint流程是大概下面这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$@</span>"</span> = <span class="string">'app run'</span> <span class="_">-a</span> <span class="_">-f</span> <span class="string">'requirements.txt'</span> ];<span class="keyword">then</span></div><div class="line">	pip install -r requirements.txt</div><div class="line">	<span class="built_in">exec</span> python manage.py runserver 0.0.0.0:8000</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></div></pre></td></tr></table></figure></p>
<p>大概上面这样，其实不确定流程是啥样或者想从某个基础镜像构建自己需要的镜像的话一个是可以去dockerhub上参照别人或者官方写的dockerfile<br>然后可以用docker -ti 镜像名 /bin/bash (如果你的业务需要网络做自己做端口映射,同理配置文件挂载进去)先进容器里<br>安装一些东西后把你的进程起来后(这个时候容器主进程是bash,无所谓你的业务进程是否是前后台,不过最好前台，可以看输出)再把这些流程写成dockerfile(做成通用型镜像或者需要在容器启动后执行而且构建镜像的时候执行的就写到entrypoint脚本里,)<br>另外容器里可能很多命令没有，你把相应的配置文件挂载进去你可以在宿主机上面修改<br>前不久制作了一个npm的通用型镜像过程在地址<a href="https://github.com/zhangguanzhang/docker-compose_nodejs" target="_blank" rel="external">https://github.com/zhangguanzhang/docker-compose_nodejs</a><br>是nodejs和mysql的,里面有我写的entrypoint脚本,dockerfile参考官方的增加了entrypoint部分，用的是docker-compose，docker-compose是个容器编排工具，根据你写的yml文件内容来启动和设置容器的属性参数啥的，很多方便</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

