<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Zhangguanzhang">
  <!-- Open Graph Data -->
  <meta property="og:title" content="shell多进程并发执行"/>
  <meta property="og:description" content="记录生活点滴" />
  <meta property="og:site_name" content="Zhangguanzhang"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://zhangguanzhang.github.ioundefined"/>
  <meta name="baidu-site-verification" content="RqbanSZBE3" />
  
    <link rel="alternate" href="/atom.xml" title="Zhangguanzhang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Zhangguanzhang</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">shell多进程并发执行</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/zhangguanzhang">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:zhangguanzhang@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Zhangguanzhang</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2017-04-15</span>
            <span class="time">16:03:33</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/日志/">日志</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/shell/">#shell</a> <a class="tag" href="/tags/linux/">#linux</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>图文记录下shell多进程<br><a id="more"></a></p>
<h3 id="虽说shell的多进程是后台执行-但是学会了再写一些脚本的时候非常方便"><a href="#虽说shell的多进程是后台执行-但是学会了再写一些脚本的时候非常方便" class="headerlink" title="虽说shell的多进程是后台执行,但是学会了再写一些脚本的时候非常方便"></a>虽说shell的多进程是后台执行,但是学会了再写一些脚本的时候非常方便</h3><p>先看传统的后台多进程方式,写个shell来举例<br>先是正常的运行</p>
<pre><code>[root@guan ~]# cat>test.sh<<'eof'> #!/bin/bash
> start=`date +%s`
> for i in `seq 10`;do
> echo $i;sleep 2
> done
> echo 'Time:' "$((`date +%s`-start))"
> eof
[root@guan ~]# sh test.sh
1
2
3
4
5
6
7
8
9
10
Time: 20
[root@guan ~]# 
</'eof'></code></pre>

<p>然后是后台运行来节约时间</p>
<pre><code>[root@guan ~]# cat>test.sh<<'eof'> #!/bin/bash
> start=`date +%s`
> for i in `seq 10`;do
>  { echo $i;sleep 2; }& #后台运行
> done
> wait #等待所有后台进程运行完成
> echo 'Time:' "$((`date +%s`-start))"
> eof
[root@guan ~]# sh test.sh 
1
2
5
6
7
9
4
8
3
10
Time: 2
[root@guan ~]# 
</'eof'></code></pre>

<p>从上面结果对比发现时间大大缩短,但是缺点是不能控制数量<br>然后因为wait特性我们可以用它来配合数字来自定并发的数量</p>
<pre><code>[root@guan ~]# cat>test.sh<<'eof' 1="" 2="" 3="" 4="" 5="" 6="" 7="" 8="" 9="" 10="" #!="" bin="" bash="" max_process="5;" start="`date" +%s`="" for="" i="" in="" `seq="" 10`;do="" {="" echo="" $i;sleep="" 2;="" }&="" #后台运行="" ((count++));((do_count++))="" #次数和运行的次数计数="" [="" "do_count"="" -eq="" '10'="" ]="" &&="" wait;break;="" }="" #="" 这里的10是需要执行的总次数="" 运行过的次数等于总次数就等待所有后台退出,但是假设每次并发="" 的次数是3,最后有一个进程,上下俩行就是为了防止这种情况出现="" "$count"="" "$max_process"="" wait;count="0;" done="" 'time:'="" "$((`date="" +%s`-start))"="" eof="" [root@guan="" ~]#="" sh="" test.sh="" time:="" <="" code=""></'eof'></code></pre>

<p>这种还要考虑需要并发的进程数量在总次数下是否有余数的可能,后面我发现了可以用mkfifo来实现并发,代码更容易懂</p>
<p>无名管道： 就是我们经常使用的 例如： cat text | grep “abc” </p>
<p>那个“|”就是管道，只不过是无名的，可以直接作为两个进程的数据通道</p>
<p>有名管道： mkfilo  可以创建一个管道文件 ，例如： mkfifo　fifo_file</p>
<p>管道有一个特点，如果管道中没有数据，那么取管道数据的操作就会停滞，直到</p>
<p>管道内进入数据，然后读出后才会终止这一操作，同理，写入管道的操作</p>
<p>如果没有读取操作，这一个动作也会停滞。<br><img src="http://s3.51cto.com/wyfs02/M00/24/7C/wKiom1NQHk-DQPSDAABjOdvRLD4666.jpg" alt=""><br>当我们试图用echo想管道文件中写入数据时，由于没有任何进程在对它做读取操作，所以</p>
<p>它会一直停留在那里等待读取操作，此时我们在另一终端上用cat指令做读取操作<br><img src="http://s3.51cto.com/wyfs02/M02/24/7B/wKioL1NQHibQwp6rAACaUgamBvs703.jpg" alt=""><br>你会发现读取操作一旦执行，写入操作就可以顺利完成了，同理，先做读取操作也是一样的(不信可以自行测试)</p>
<p>后面发现的多进程就是利用管道的读写来控制,exec绑定文件操作符重定向</p>
<p>exec绑定文件操作符后我们来试试按行读取会有啥现象</p>
<pre><code>[root@guan ~]# exec 5<>test_fifo
[root@guan ~]# echo '123' >&5
[root@guan ~]# read -u5  # -u选项是表示从文件描叙符里读取管道里的一行
[root@guan ~]# read -u5
^C            # 上面管道里只有一行,读取第二行会停滞在这
[root@guan ~]# echo -e '123\n123' >&5
[root@guan ~]# read -u5
[root@guan ~]# read -u5
[root@guan ~]# read -u5
^C          # 管道里俩行,读取第三行会停滞
</code></pre>

<p>管道来并发控制就是先在管道里写入要并发数量的行数<br>每次read一行后后面把要后台的任务用大括号包起来后台了<br>然后大括号里面的最后一句是向管道里写入一行,只有后台任务执行完了下一个read -u才不会停滞<br>举个例子3条任务,并发数量为2,一开始管道里写入2行<br>然后下面代码</p>
<pre><code>mkfifo test_fifo
exec 5<>test_fifo
rm -f test_fifo
seq 2>&5
for i in {1..3};do
    read -u5
    {
        echo $i;sleep 2;  #需要并发的内容统一写在大括号里
        echo >&5
    }&
done
wait
</code></pre>

<p>脑补下执行过程,进入循环中:<br>第一次read(管道里有2行)不会被停滞,管道剩下1行,大括号里的所有代码放在后台(一个后台并发)<br>第二次read(管道里有1行)不会被停滞,管道剩下0行,大括号里的所有代码放在后台(俩个后台并发)<br>第三次read(管道里有0行),会被停滞,只有等一个后台执行完了(后台里最后一句)向管道里写入了一个空行,此次的read才会退出停滞状态后面的代码才能继续执行<br>然后循环结束后最后还有第三次的后台,此处写个wait即可</p>
<p>然后下面是完整的例子</p>
<pre><code>
    [root@guan ~]# cat -n test.sh 
     1    #!/bin/bash
     2    
     3    trap "exec 5>&-;exec 5<$-;exit 2="" 4="" 5="" 6="" 7="" 8="" 9="" 0"="" #捕捉中断信号="" （ctrl="" +c）关闭fd="" 5的意思,善后工作="" max_process="$1" pipe="`mktemp" -u="" tmp.xxxx`="" mkfifo="" $pipe="" exec="" 5<="">$pipe      #这个数值不是0,1,2就行,范围是3-$((`ulimit -u`-1))
    10    rm -f $pipe
    11    
    12    seq $max_process>&5   #写入并发数量的行
    13    
    14    start=`date +%s`
    15    for i in {1..10};do
    16        read -u5
    17        {
    18            echo $i;sleep 2;
    19            echo >&5
    20        }&
    21    done
    22    wait
    23    echo 'Time:' "$((`date +%s`-start))"
    24    
    25    exec 5>$-;exec 5<$- 1="" 2="" 3="" 4="" 5="" 6="" 7="" 8="" 9="" 10="" #="" #关闭文件操作符必须分开写="" [root@guan="" ~]#="" sh="" test.sh="" time:="" <="" code=""></$-></$-;exit></code></pre>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

